package dev.rafandoo.gitwit.service.git;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import dev.rafandoo.gitwit.enums.GitConfigScope;
import dev.rafandoo.gitwit.enums.GitRepositoryParam;
import dev.rafandoo.gitwit.exception.GitWitException;
import dev.rafandoo.gitwit.service.MessageService;
import lombok.AllArgsConstructor;
import org.eclipse.jgit.errors.ConfigInvalidException;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.StoredConfig;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.stream.Stream;

import static dev.rafandoo.gitwit.service.git.GitConfigService.GIT_CONFIG_CORE;
import static dev.rafandoo.gitwit.service.git.GitConfigService.GIT_CONFIG_HOOKS_PATH;

@Singleton
@AllArgsConstructor(onConstructor_ = @__({@Inject}))
public final class GitHookService {

    private final GitService gitService;
    private final GitConfigService gitConfigService;
    private final MessageService messageService;

    /**
     * Retrieves the hooks directory for the current Git repository.
     *
     * @return {@link Path} to the hooks directory.
     * @throws GitWitException if the hooks directory cannot be created or accessed.
     */
    public Path getGitHooks() {
        Path hooksDir = this.gitService.getRepo().resolve(GitRepositoryParam.HOOKS_DIR_NAME.get().asString());

        try {
            if (!Files.exists(hooksDir)) {
                Files.createDirectories(hooksDir);
                this.messageService.debug("git.hooks.created", hooksDir);
            }

            // Migrate existing hooks (skip *.sample)
            Path defaultHooks = this.gitService.getGit().resolve(Constants.HOOKS);
            if (Files.isDirectory(defaultHooks)) {
                try (Stream<Path> files = Files.list(defaultHooks)) {
                    files.filter(Files::isRegularFile)
                        .filter(p -> !p.getFileName().toString().endsWith(".sample"))
                        .forEach(file -> this.moveHookFile(file, hooksDir.resolve(file.getFileName())));
                }
            }
            return hooksDir;
        } catch (IOException e) {
            throw new GitWitException("git.hook.error.move_default_hooks", e);
        }
    }

    /**
     * Moves a hook file from one location to another, replacing the destination if it already exists.
     *
     * @param src  the source {@link Path} of the file to be moved.
     * @param dest the destination {@link Path} where the file will be moved.
     * @throws GitWitException if an I/O error occurs during file movement.
     */
    private void moveHookFile(Path src, Path dest) {
        try {
            Files.move(src, dest, StandardCopyOption.REPLACE_EXISTING);
            this.messageService.debug(
                "git.hooks.moved",
                src,
                dest
            );
        } catch (IOException e) {
            throw new GitWitException("git.hook.error.move_failed", e, src.toString());
        }
    }

    /**
     * Installs (or updates) the GitWit hook and switches <code>core.hooksPath</code> to
     * {@link GitRepositoryParam#HOOKS_DIR_NAME}. If the hook already exists and the user did not request <code>--force</code>, the
     * method exits early with an informational message.
     *
     * @param forceInstall whether to overwrite an existing hook.
     */
    public void setupCommitWizardHook(boolean forceInstall) {
        Path hookFile = this.getGitHooks().resolve(GitRepositoryParam.PREPARE_COMMIT_MSG.get().asString());

        if (Files.exists(hookFile) && !forceInstall) {
            this.messageService.info(
                "git.hooks.exists"
            );
            return;
        }

        this.createPrepareCommitMsgHook(hookFile);
        this.configureGitHooks();
    }

    /**
     * Creates a prepare-commit-msg hook script for the Commit Wizard.
     *
     * @param hookFile the {@link Path} where the hook script will be written.
     * @throws GitWitException if there is an error writing the hook script.
     */
    private void createPrepareCommitMsgHook(Path hookFile) {
        String script = "#!/usr/bin/env bash\n" +
            "# Auto‑generated by GitWit — do not edit manually.\n" +
            "COMMIT_MSG_FILE=\"$1\"\n" +
            "# Ignore merge & squash commits\n" +
            "case \"$2\" in\n" +
            "  merge|squash) exit 0 ;;\n" +
            "esac\n" +
            "# Run the Commit Wizard to obtain the message\n" +
            this.gitConfigService.getAliasCommand().replace("!", "") + " hook $COMMIT_MSG_FILE || {\n" +
            "  echo 'Commit Wizard failed; aborting commit.' >&2\n" +
            "  exit 1\n" +
            "}\n";

        try {
            Files.writeString(
                hookFile,
                script,
                StandardCharsets.UTF_8,
                StandardOpenOption.CREATE,
                StandardOpenOption.TRUNCATE_EXISTING
            );
            // Make sure the hook is executable (best‑effort on non‑POSIX file systems)
            try {
                Files.setPosixFilePermissions(hookFile, PosixFilePermissions.fromString("rwxr-xr-x"));
            } catch (UnsupportedOperationException ignored) {
                // Non‑POSIX FS (e.g. Windows) – Git will still attempt to execute .sh via sh.exe
            }
            this.messageService.debug("git.hooks.written", hookFile.toString());
        } catch (IOException e) {
            throw new GitWitException("git.hook.error.hook_write", e);
        }
    }

    /**
     * Configures the Git hooks directory for the repository.
     * <p>
     * Sets the hooks path to {@link GitRepositoryParam#HOOKS_DIR_NAME} and saves the configuration.
     *
     * @throws GitWitException if there is an error accessing or modifying the Git configuration.
     */
    private void configureGitHooks() {
        try {
            StoredConfig config = this.gitConfigService.load(GitConfigScope.LOCAL);
            config.load();
            if (
                !GitRepositoryParam.HOOKS_DIR_NAME.get()
                    .asString()
                    .equals(config.getString(GIT_CONFIG_CORE, null, GIT_CONFIG_HOOKS_PATH))
            ) {
                config.setString(
                    GIT_CONFIG_CORE,
                    null,
                    GIT_CONFIG_HOOKS_PATH,
                    GitRepositoryParam.HOOKS_DIR_NAME.get().asString()
                );

                config.setString(
                    GIT_CONFIG_CORE,
                    null,
                    "editor",
                    GitRepositoryParam.CORE_EDITOR_CAT.get().asString()
                );

                config.save();
                this.messageService.info(
                    "git.hooks.path_set",
                    GitRepositoryParam.HOOKS_DIR_NAME.get().asString()
                );
                this.messageService.info(
                    "git.hooks.editor_set",
                    GitRepositoryParam.CORE_EDITOR_CAT.get().asString()
                );
            }
        } catch (IOException e) {
            throw new GitWitException("git.hook.error.core_hook_path", e);
        } catch (ConfigInvalidException e) {
            throw new GitWitException("git.error.config_invalid", e);
        }
    }

    /**
     * Uninstalls the GitWit commit wizard hook from the local Git repository.
     * <p>
     * This method performs the following actions:
     * <ul>
     *   <li>Deletes the prepare-commit-msg hook file if it exists</li>
     *   <li>Removes the custom hooks path and editor configuration from the local Git config</li>
     * </ul>
     *
     * @throws GitWitException if an error occurs during hook removal or configuration modification.
     */
    public void uninstallCommitWizardHook() {
        Path hookFile = this.getGitHooks().resolve(GitRepositoryParam.PREPARE_COMMIT_MSG.get().asString());
        try {
            if (Files.exists(hookFile)) {
                Files.delete(hookFile);
                this.messageService.info("git.hooks.removed", hookFile);
            } else {
                this.messageService.info("git.hooks.none_to_remove");
            }

            StoredConfig config = this.gitConfigService.load(GitConfigScope.LOCAL);
            config.load();
            String configuredHooksPath = config.getString(GIT_CONFIG_CORE, null, GIT_CONFIG_HOOKS_PATH);

            if (GitRepositoryParam.HOOKS_DIR_NAME.get().asString().equals(configuredHooksPath)) {
                config.unset(GIT_CONFIG_CORE, null, GIT_CONFIG_HOOKS_PATH);
                config.unset(GIT_CONFIG_CORE, null, "editor");
                config.save();
                this.messageService.info("git.hooks.config_cleared");
            } else {
                this.messageService.info("git.hooks.not_configured");
            }
        } catch (IOException e) {
            throw new GitWitException("git.error.init_failed", e);
        } catch (ConfigInvalidException e) {
            throw new GitWitException("git.error.config_invalid", e);
        }
    }

    /**
     * Checks if the Commit Wizard hook is currently enabled in the Git repository.
     *
     * @return {@code true} if the prepare-commit-msg hook exists, {@code false} otherwise.
     */
    public boolean isCommitWizardHookEnabled() {
        return Files.exists(this.getGitHooks().resolve(GitRepositoryParam.PREPARE_COMMIT_MSG.get().asString()));
    }

}
